A lightweight simulation and motion planning toolbox for C++

# Introduction #

Simox is a leightweight platform indepedent C++ toolbox containing three libraries for 3D simulation of robot systems, sampling based motion planning and grasp planning. The VirtualRobot? library is used to define complex robot systems which may cover multiple robots with many degrees of freedom. The robot structure and it's visualisation can be easily defined via XML files and environments with obstacles and objects to manipulate are supported. The libraries GraspStudio? and Saba use these definitions for planning grasps or collision-free motions. State-of-the-art implementations of sampling-based motion planning algorithms (e.g. Rapidly-exploring Random Trees) are served by the Saba library which was designed for efficient planning in high-dimensional configuration spaces. The library GraspStudio? offers possibilities to compute grasp quality scores for generic end-effector definitions (e.g. a humanoid hand). The implemented 6D wrench-space computations, offer the possibility to easily (and quickly) measure the quaility of an applied grasp to an object. Furthermore, the implemented planners are able to generate grasp maps for given objects automatically. The only external dependencies that are need on your system are: QT (a platform independent window toolkit) and Coin3D (an open inventor implementation) together with SoQt? (to visualize open inventor scenes in QT windows) Virtual-Robot


# Details #

The main element of the VirtualRobot? library is CRobot, an instance of a robot that is loaded from an XML definition file. Here, all joints (called RobotNodes?) are defined via Denavit-Hartenberg conventions or an easy-to-use "Translation+Rotation" scheme. Furthermore, names, IDs, joint limits, sensors, visualization and collision models are defined in this file. For convenient acces kinematic chains and collections of collision models can be additionally defined. An instance of such a robot definition can be visualized by a viewer to show the current state of a robot. Furthermore, environments, obstacles and objects to manipulate can be defined and visualized. Thus it is possible to construct complex scenes used for simulation or planning and to store and load such scene defintions to/from XML files. The main features of the library are:
A generic definition of end effectors allows to realize complex hands (e.g. humanoid hands can be defined). End effectors can be opened/closed and contact information can be retrieved e.g. for grasp scoring. The library defines an interface for collision checking, allowing to exchange the collision checker used for determining distances or collisions. Currently the PQP collision checker is used due to it's fast and robust implementation. A generic computation of Jacobains and it's Pseudoinverse are offered for arbitrary kinematic chains A generic IK solver, utilizing randomized approaches, is implemented for solving the IK for redundant kinematic chains Reachability disributrions are supported, in order to precompute the 6D reachability of a kinematic structure (e.g. an arm) and to quickly decide whether a psoe in workspace is reachable or not It is possible to store and load object-related grasping information for a given end-effector, which directly can be used within the IK solvers Multithreading is supported, e.g. multiple instances of the collsiion checker can be used to parallelize collision checks
Saba

The Sampling Based Motion Planning Library is designed to efficiently compute collision-free motions for redundant robot systems with many degrees of freedom. The algorithms provided are based on Rapidly-exploring Random Trees (RRT), which allow a quick sampling of the collision-free configuration space. Several planners, starting with the basic RRT\_Connect planner, are implemented and a lot of tools e.g. for path smoothing or visualizing are provided. The main features are:
To manage multiple collision chekcs (e.g. between different parts of a robot, between multiple robots and/or obstacles), the CCollisionCheckingManagement (CCM) class provides an intuitive way of defining a set of collision models for which mutual collisions should be checked. Classes for handling configuration spaces are given, which can be configured depending on the demonads (e.g. CCMs and sampling / collision checking step sized can be specified). The commonly used class CSpaceSampled offers methods for determining whether a single configuration or a complete path is in C-Free or not. Efficient implemtnations for path checking are given, e.g. recursive divide-and-konquer algorithms for efficient ccollision testing of c-space paths. The basic RRT-based algorithms are implemented, RRT-Extend, RRT-Connect and BiRRT with some variants. Additionally more sophisticated palnners (e.g. Goal-Sampling RRTs as the IK-RRT or the Bimanual IK-RRT, planners considering constraints, planners doing a multi-threaded search and planners giving guarantees with FreeBubbles?) are provided. Methods to visualize RRTs, solution paths or CSpaces given. Path-Optimizations with elastic bands or by searching shortcuts in C-space can be done. Multi-threading support: All planners and optimizers can be started in own threads. For robot specific code, extra libraries can be included. E.g. for ARMAR-III the RobotLibArmarIII provides planners, IK-solvers and tools which are ARMAR specific.
GraspStudio?

The GraspStudio? library contains methods and tools used for measuring grasp qualities. Therefore an interface to the qhull library is provided to build convex hulls in 3D or 6D. The methods for measuring grasp qualities implement methods based on force-space relatated algorithms in 3D and a full implementation of 6D grasp wrench spaces is included. Grasping setups of simple end-effectors, multi-finger hands, multi-hand and multi-robot grasps can be scored by the GraspStudio? library. Grasp planners are implemented for building object specific grasp maps for a given end-effector.